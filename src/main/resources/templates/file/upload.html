<!DOCTYPE html>
<html
  lang="ko"
  xmlns:th="http://www.thymeleaf.org"
  xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
  layout:decorate="~{layout/main}"
>
  <body>
    <div layout:fragment="content">
      <div
        class="container mx-auto px-4 py-8 max-w-5xl"
        x-data="uploadPageState()"
        @alpine:init="init()"
        @beforeunload.window="destroySseConnection()"
      >

        <!-- Success Alert -->
        <div th:if="${success}" class="alert alert-success mb-4 shadow-lg" x-data="{ show: true }" x-show="show" x-init="setTimeout(() => show = false, 5000)">
          <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
          <span th:text="${success}">Success message</span>
          <button @click="show = false" class="btn btn-sm btn-ghost">âœ•</button>
        </div>

        <!-- Error Alert -->
        <div th:if="${error}" class="alert alert-error mb-4 shadow-lg" x-data="{ show: true }" x-show="show">
          <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
          <span th:text="${error}">Error message</span>
          <button @click="show = false" class="btn btn-sm btn-ghost">âœ•</button>
        </div>

        <div class="grid grid-cols-1 gap-6">
          <!-- Upload Function Card -->
          <div id="uploadFunctionCard" class="col-span-full">
            <div class="card bg-base-100 shadow-xl">
              <div class="card-body">
                <!-- Dynamic Title Based on File Type -->
                <h2 class="card-title text-2xl">
                  <i :class="fileTypeIcon" class="text-primary"></i>
                  <span x-text="fileTypeTitle"></span>
                </h2>
                <p class="text-sm text-base-content opacity-70 mb-4" x-text="fileTypeDescription"></p>

                <!-- Processing Mode Selector Fragment -->
                <div class="mb-6 pb-6 border-b">
                  <th:block th:replace="~{fragments/processing-mode-selector :: mode-selector(selected='AUTO')}" />
                </div>

                <!-- Upload Form -->
                <form id="uploadForm" @submit.prevent="handleUpload()">
                  <!-- File Input -->
                  <div class="form-control w-full">
                    <label class="label">
                      <span class="label-text font-semibold">
                        <i class="fas fa-file-upload text-primary mr-1"></i>
                        íŒŒì¼ ì„ íƒ
                      </span>
                    </label>
                    <input
                      id="fileInput"
                      type="file"
                      name="file"
                      :accept="fileAccept"
                      class="file-input file-input-bordered file-input-primary w-full"
                      required
                      @change="handleFileSelection"
                    />
                    <label class="label">
                      <span class="label-text-alt">ìµœëŒ€ íŒŒì¼ í¬ê¸°: 100MB</span>
                      <span id="fileInfo" class="label-text-alt font-semibold text-primary" x-text="fileInfo"></span>
                    </label>
                  </div>

                  <!-- File Type Warning (if not recognized) -->
                  <div x-show="!isValidFileType" class="alert alert-warning mt-4">
                    <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>
                    <div>
                      <h4 class="font-bold">ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹</h4>
                      <div class="text-xs">
                        <p>LDIF (.ldif) ë˜ëŠ” Master List (.ml) íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.</p>
                      </div>
                    </div>
                  </div>

                  <!-- Checksum input removed, will be calculated on the backend -->

                  <!-- Hidden Fields -->
                  <input type="hidden" name="forceUpload" value="false" />
                  <input type="hidden" name="processingMode" x-model="processingMode" />

                  <!-- Action Buttons -->
                  <div class="card-actions justify-end mt-6">
                    <button type="button" onclick="window.location.href='/upload-history'" class="btn btn-outline gap-2">
                      <i class="fas fa-history"></i>
                      ì—…ë¡œë“œ ì´ë ¥
                    </button>
                    <button type="submit" id="uploadBtn" class="btn btn-primary gap-2" :disabled="isProcessing">
                      <span x-show="isProcessing" class="loading loading-spinner"></span>
                      <i x-show="!isProcessing" class="fas fa-cloud-upload-alt"></i>
                      ì—…ë¡œë“œ
                    </button>
                  </div>
                </form>
              </div>
            </div>
          </div>

          <!-- Upload Process Card -->
          <div id="uploadProcessCard" class="col-span-full mt-6"
               x-show="uploadId"
               x-transition:enter="transition ease-out duration-300"
               x-transition:enter-start="opacity-0 transform -translate-y-2"
               x-transition:enter-end="opacity-100 transform translate-y-0"
          >
            <div class="card bg-base-100 shadow-xl">
              <div class="card-body">
                <h3 class="card-title text-lg mb-4">
                  <i class="fas fa-tasks text-info"></i>
                  ì²˜ë¦¬ ì§„í–‰ ìƒí™© (<span class="font-mono text-sm" x-text="uploadId"></span>)
                </h3>

                <!-- Stage Progress Bars -->
                <div class="space-y-4">
                    <!-- Upload Stage -->
                    <template x-if="uploadStage.active">
                        <div>
                            <div class="flex justify-between items-center mb-1">
                                <span class="font-semibold" :class="{'text-success': uploadStage.status === 'COMPLETED', 'text-error': uploadStage.status === 'FAILED'}">
                                    <i class="fas" :class="{'fa-check-circle': uploadStage.status === 'COMPLETED', 'fa-times-circle': uploadStage.status === 'FAILED', 'fa-upload': uploadStage.status !== 'COMPLETED' && uploadStage.status !== 'FAILED'}"></i>
                                    íŒŒì¼ ì—…ë¡œë“œ
                                </span>
                                <span class="text-sm font-mono" x-text="uploadStage.percentage + '%'"></span>
                            </div>
                            <progress class="progress w-full" :class="{'progress-success': uploadStage.status === 'COMPLETED', 'progress-error': uploadStage.status === 'FAILED', 'progress-info': uploadStage.status !== 'COMPLETED' && uploadStage.status !== 'FAILED'}" :value="uploadStage.percentage" max="100"></progress>
                            <p class="text-xs text-gray-500 mt-1" x-text="uploadStage.message"></p>
                        </div>
                    </template>
                    <!-- Parse Stage -->
                    <template x-if="parseStage.active">
                        <div>
                            <div class="flex justify-between items-center mb-1">
                                <span class="font-semibold" :class="{'text-success': parseStage.status === 'COMPLETED', 'text-error': parseStage.status === 'FAILED'}">
                                    <i class="fas" :class="{'fa-check-circle': parseStage.status === 'COMPLETED', 'fa-times-circle': parseStage.status === 'FAILED', 'fa-cogs': parseStage.status !== 'COMPLETED' && parseStage.status !== 'FAILED'}"></i>
                                    íŒŒì¼ íŒŒì‹±
                                </span>
                                <span class="text-sm font-mono" x-text="parseStage.percentage + '%'"></span>
                            </div>
                            <progress class="progress w-full" :class="{'progress-success': parseStage.status === 'COMPLETED', 'progress-error': parseStage.status === 'FAILED', 'progress-info': parseStage.status !== 'COMPLETED' && parseStage.status !== 'FAILED'}" :value="parseStage.percentage" max="100"></progress>
                            <p class="text-xs text-gray-500 mt-1" x-text="parseStage.message"></p>
                            <!-- Detailed info for parsing -->
                            <template x-if="parseStage.details">
                                <div class="text-xs mt-2 p-2 bg-base-200 rounded">
                                    <div class="font-semibold mb-1">ğŸ“‹ íŒŒì‹± ìƒì„¸:</div>
                                    <div class="grid grid-cols-3 gap-2" x-html="parseStage.details"></div>
                                </div>
                            </template>
                        </div>
                    </template>
                    <!-- Validate Stage -->
                    <template x-if="validateStage.active">
                        <div>
                            <div class="flex justify-between items-center mb-1">
                                <span class="font-semibold" :class="{'text-success': validateStage.status === 'COMPLETED', 'text-error': validateStage.status === 'FAILED'}">
                                    <i class="fas" :class="{'fa-check-circle': validateStage.status === 'COMPLETED', 'fa-times-circle': validateStage.status === 'FAILED', 'fa-shield-alt': validateStage.status !== 'COMPLETED' && validateStage.status !== 'FAILED'}"></i>
                                    ì¸ì¦ì„œ ê²€ì¦
                                </span>
                                <span class="text-sm font-mono" x-text="validateStage.percentage + '%'"></span>
                            </div>
                            <progress class="progress w-full" :class="{'progress-success': validateStage.status === 'COMPLETED', 'progress-error': validateStage.status === 'FAILED', 'progress-info': validateStage.status !== 'COMPLETED' && validateStage.status !== 'FAILED'}" :value="validateStage.percentage" max="100"></progress>
                            <p class="text-xs text-gray-500 mt-1" x-text="validateStage.message"></p>
                            <!-- Detailed info for validation -->
                            <template x-if="validateStage.details">
                                <div class="text-xs mt-2 p-2 bg-base-200 rounded">
                                    <div class="font-semibold mb-1">ğŸ” ê²€ì¦ ìƒì„¸:</div>
                                    <div class="grid grid-cols-3 gap-2" x-html="validateStage.details"></div>
                                </div>
                            </template>
                        </div>
                    </template>
                    <!-- LDAP Stage -->
                    <template x-if="ldapStage.active">
                        <div>
                            <div class="flex justify-between items-center mb-1">
                                <span class="font-semibold" :class="{'text-success': ldapStage.status === 'COMPLETED', 'text-error': ldapStage.status === 'FAILED'}">
                                    <i class="fas" :class="{'fa-check-circle': ldapStage.status === 'COMPLETED', 'fa-times-circle': ldapStage.status === 'FAILED', 'fa-database': ldapStage.status !== 'COMPLETED' && ldapStage.status !== 'FAILED'}"></i>
                                    LDAP ì €ì¥
                                </span>
                                <span class="text-sm font-mono" x-text="ldapStage.percentage + '%'"></span>
                            </div>
                            <progress class="progress w-full" :class="{'progress-success': ldapStage.status === 'COMPLETED', 'progress-error': ldapStage.status === 'FAILED', 'progress-info': ldapStage.status !== 'COMPLETED' && ldapStage.status !== 'FAILED'}" :value="ldapStage.percentage" max="100"></progress>
                            <p class="text-xs text-gray-500 mt-1" x-text="ldapStage.message"></p>
                            <!-- Detailed info for LDAP upload -->
                            <template x-if="ldapStage.details">
                                <div class="text-xs mt-2 p-2 bg-base-200 rounded">
                                    <div class="font-semibold mb-1">ğŸ’¾ LDAP ì €ì¥ ìƒì„¸:</div>
                                    <div class="grid grid-cols-3 gap-2" x-html="ldapStage.details"></div>
                                </div>
                            </template>
                        </div>
                    </template>
                </div>

                <!-- Manual Mode Control Panel -->
                <div x-show="processingMode === 'MANUAL' && uploadId && overallStatus !== 'FINALIZED'" class="mt-6 border-t pt-4">
                    <h4 class="font-bold text-md mb-3">ìˆ˜ë™ ì²˜ë¦¬ ì œì–´</h4>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                        <!-- Parse Button -->
                        <button
                            :disabled="parsingCompleted || parsingInProgress"
                            @click="triggerParse()"
                            class="btn btn-sm"
                            :class="{
                                'btn-success': parsingCompleted,
                                'btn-primary': !parsingCompleted && !parsingInProgress,
                                'btn-neutral loading loading-spinner': parsingInProgress
                            }">
                            <i x-show="!parsingInProgress" class="fas" :class="{'fa-check-circle': parsingCompleted, 'fa-play': !parsingCompleted}"></i>
                            <span x-text="parsingCompleted ? 'íŒŒì‹± ì™„ë£Œ' : (parsingInProgress ? 'íŒŒì‹± ì¤‘...' : 'íŒŒì‹± ì‹œì‘')"></span>
                        </button>

                        <!-- Validate Button -->
                        <button
                            :disabled="!parsingCompleted || validationCompleted || validationInProgress"
                            @click="triggerValidate()"
                            class="btn btn-sm"
                            :class="{
                                'btn-success': validationCompleted,
                                'btn-primary': parsingCompleted && !validationCompleted && !validationInProgress,
                                'btn-neutral loading loading-spinner': validationInProgress
                            }">
                            <i x-show="!validationInProgress" class="fas" :class="{'fa-check-circle': validationCompleted, 'fa-play': !validationCompleted}"></i>
                            <span x-text="validationCompleted ? 'ê²€ì¦ ì™„ë£Œ' : (validationInProgress ? 'ê²€ì¦ ì¤‘...' : 'ê²€ì¦ ì‹œì‘')"></span>
                        </button>

                        <!-- LDAP Upload Button -->
                        <button
                            :disabled="!validationCompleted || ldapCompleted || ldapInProgress"
                            @click="triggerLdapUpload()"
                            class="btn btn-sm"
                            :class="{
                                'btn-success': ldapCompleted,
                                'btn-primary': validationCompleted && !ldapCompleted && !ldapInProgress,
                                'btn-neutral loading loading-spinner': ldapInProgress
                            }">
                            <i x-show="!ldapInProgress" class="fas" :class="{'fa-check-circle': ldapCompleted, 'fa-play': !ldapCompleted}"></i>
                            <span x-text="ldapCompleted ? 'LDAP ì €ì¥ ì™„ë£Œ' : (ldapInProgress ? 'LDAP ì €ì¥ ì¤‘...' : 'LDAP ì €ì¥ ì‹œì‘')"></span>
                        </button>
                    </div>
                </div>

                <!-- Final Status Message -->
                <div x-show="overallStatus === 'FINALIZED' || overallStatus === 'FAILED'" class="mt-6 alert" :class="{'alert-success': overallStatus === 'FINALIZED', 'alert-error': overallStatus === 'FAILED'}">
                     <i class="fas" :class="{'fa-check-circle': overallStatus === 'FINALIZED', 'fa-exclamation-triangle': overallStatus === 'FAILED'}"></i>
                    <span x-text="overallMessage"></span>
                </div>

              </div>
            </div>
          </div>

          <!-- Error Card -->
          <div x-show="errorMessages.length > 0" class="col-span-full mt-6"
               x-transition:enter="transition ease-out duration-300"
               x-transition:enter-start="opacity-0"
               x-transition:enter-end="opacity-100"
          >
              <div class="card bg-red-100 border border-red-400 text-red-700 shadow-xl">
                  <div class="card-body">
                      <div class="flex justify-between items-center">
                        <h3 class="card-title text-lg">
                            <i class="fas fa-exclamation-triangle"></i>
                            ì˜¤ë¥˜ ë°œìƒ
                        </h3>
                        <button @click="errorMessages = []" class="btn btn-sm btn-ghost">âœ•</button>
                      </div>
                      <ul class="list-disc list-inside mt-2 space-y-1 text-sm">
                          <template x-for="(error, index) in errorMessages" :key="index">
                              <li x-text="error"></li>
                          </template>
                      </ul>
                  </div>
              </div>
          </div>
        </div>
      </div>

      <!-- Duplicate Warning Modal -->
      <dialog id="duplicateModal" class="modal">
        <div class="modal-box max-w-2xl">
          <form method="dialog">
            <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button>
          </form>
          <h3 class="font-bold text-lg text-warning mb-4">
            <i class="fas fa-exclamation-triangle mr-2"></i>
            ì¤‘ë³µ íŒŒì¼ ê²½ê³ 
          </h3>

          <div class="alert alert-warning mb-4">
            <p id="duplicateMessage"></p>
          </div>

          <div class="overflow-x-auto">
            <table class="table table-sm">
              <tbody>
                <tr>
                  <th>íŒŒì¼ëª…</th>
                  <td id="dupFileName" class="font-mono text-xs">-</td>
                </tr>
                <tr>
                  <th>ì—…ë¡œë“œ ID</th>
                  <td id="dupFileId" class="font-mono text-xs">-</td>
                </tr>
                <tr>
                  <th>ì—…ë¡œë“œ ì¼ì‹œ</th>
                  <td id="dupUploadDate">-</td>
                </tr>
                <tr>
                  <th>ìƒíƒœ</th>
                  <td id="dupStatus">-</td>
                </tr>
              </tbody>
            </table>
          </div>

          <div class="modal-action">
              <button class="btn btn-outline" onclick="document.getElementById('duplicateModal').close()">ì·¨ì†Œ</button>
              <button class="btn btn-info gap-2" @click="viewExistingFile()">
                <i class="fas fa-eye"></i>
                ê¸°ì¡´ íŒŒì¼ ë³´ê¸°
              </button>
              <button class="btn btn-error gap-2" @click="forceUpload()">
                <i class="fas fa-sync-alt"></i>
                ê°•ì œ ì—…ë¡œë“œ
              </button>
          </div>
        </div>
      </dialog>
    </div>

    <th:block layout:fragment="script-content">
      <script>
        function uploadPageState() {
          return {
            // File state
            fileType: 'unknown',
            fileTypeIcon: 'fas fa-question-circle',
            fileTypeTitle: 'íŒŒì¼ ì—…ë¡œë“œ',
            fileTypeDescription: 'íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”',
            fileAccept: '.ldif,.ml',
            isValidFileType: true,
            fileInfo: '',
            selectedFile: null,

            // Upload & Processing state
            isProcessing: false,
            existingFileId: null,
            uploadId: null,
            sseEventSource: null,
            processingMode: 'AUTO',

            // SSE reconnection state
            sseReconnectAttempts: 0,
            maxSseReconnectAttempts: 5,
            sseReconnectDelay: 2000, // Start with 2 seconds
            sseReconnectTimer: null,

            // Stage-specific progress
            uploadStage: { active: false, message: '', percentage: 0, status: '', details: '' },
            parseStage: { active: false, message: '', percentage: 0, status: '', details: '' },
            validateStage: { active: false, message: '', percentage: 0, status: '', details: '' },
            ldapStage: { active: false, message: '', percentage: 0, status: '', details: '' },

            // Overall status
            overallStatus: 'IDLE', // IDLE, IN_PROGRESS, FINALIZED, FAILED
            overallMessage: '',

            // Manual mode completion flags
            parsingCompleted: false,
            validationCompleted: false,
            ldapCompleted: false,

            // Manual mode in-progress flags
            parsingInProgress: false,
            validationInProgress: false,
            ldapInProgress: false,

            // Error collection
            errorMessages: [],

            init() {
              this.$el.addEventListener('processing-mode-changed', (event) => {
                  this.processingMode = event.detail.mode;
              });

              // Check if there's an ongoing upload from sessionStorage
              const savedUploadId = sessionStorage.getItem('currentUploadId');
              if (savedUploadId) {
                  console.log('Resuming upload from sessionStorage:', savedUploadId);
                  this.uploadId = savedUploadId;
                  this.startSseConnection();
              }
            },

            resetProgressState() {
                this.isProcessing = true;
                this.uploadId = null;

                // Clear sessionStorage
                sessionStorage.removeItem('currentUploadId');

                // Clear reconnection state
                this.sseReconnectAttempts = 0;
                this.sseReconnectDelay = 2000;
                if (this.sseReconnectTimer) {
                    clearTimeout(this.sseReconnectTimer);
                    this.sseReconnectTimer = null;
                }

                // Close SSE connection
                if (this.sseEventSource) {
                    this.sseEventSource.close();
                    this.sseEventSource = null;
                }

                this.uploadStage = { active: false, message: '', percentage: 0, status: '', details: '' };
                this.parseStage = { active: false, message: '', percentage: 0, status: '', details: '' };
                this.validateStage = { active: false, message: '', percentage: 0, status: '', details: '' };
                this.ldapStage = { active: false, message: '', percentage: 0, status: '', details: '' };
                
                this.overallStatus = 'IN_PROGRESS';
                this.overallMessage = '';

                this.parsingCompleted = false;
                this.validationCompleted = false;
                this.ldapCompleted = false;

                this.parsingInProgress = false;
                this.validationInProgress = false;
                this.ldapInProgress = false;

                this.errorMessages = [];
            },

            handleFileSelection(event) {
              this.selectedFile = event.target.files[0];
              if (!this.selectedFile) {
                  this.fileInfo = '';
                  return;
              };
              this.fileInfo = `${this.selectedFile.name} (${formatFileSize(this.selectedFile.size)})`;

              const fileName = this.selectedFile.name.toLowerCase();
              if (fileName.endsWith('.ldif')) {
                this.setFileType('ldif');
              } else if (fileName.endsWith('.ml')) {
                this.setFileType('ml');
              } else {
                this.setFileType('unknown');
              }
            },

            setFileType(type) {
                this.fileType = type;
                this.isValidFileType = type !== 'unknown';
                if (type === 'ldif') {
                    this.fileTypeIcon = 'fas fa-file-code';
                    this.fileTypeTitle = 'LDIF íŒŒì¼ ì—…ë¡œë“œ';
                    this.fileTypeDescription = 'LDAP Data Interchange Format íŒŒì¼ì„ ì—…ë¡œë“œí•©ë‹ˆë‹¤.';
                } else if (type === 'ml') {
                    this.fileTypeIcon = 'fas fa-file-signature';
                    this.fileTypeTitle = 'Master List íŒŒì¼ ì—…ë¡œë“œ';
                    this.fileTypeDescription = 'ICAO CSCA Master List (CMS ì„œëª… íŒŒì¼)ì„ ì—…ë¡œë“œí•©ë‹ˆë‹¤.';
                } else {
                    this.fileTypeIcon = 'fas fa-question-circle';
                    this.fileTypeTitle = 'ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹';
                    this.fileTypeDescription = 'LDIF (.ldif) ë˜ëŠ” Master List (.ml) íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.';
                }
            },

            async handleUpload() {
              if (!this.selectedFile || !this.isValidFileType) {
                showNotification('ì—…ë¡œë“œí•  ì˜¬ë°”ë¥¸ í˜•ì‹ì˜ íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.', 'warning');
                return;
              }
              const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB
              if (this.selectedFile.size > MAX_FILE_SIZE) {
                showNotification('íŒŒì¼ í¬ê¸°ëŠ” 100MB ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤.', 'error');
                return;
              }

              this.resetProgressState();
              this.uploadStage.active = true;

              try {
                this.updateUploadProgress('íŒŒì¼ ì—…ë¡œë“œ ì¤‘...', 50);
                await this.submitFormAjax();
              } catch (error) {
                console.error('Upload error:', error);
                this.errorMessages.push('ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                this.uploadStage.status = 'FAILED';
                this.uploadStage.message = 'ì—…ë¡œë“œ ì‹¤íŒ¨: ' + error.message;
                this.overallStatus = 'FAILED';
                this.isProcessing = false;
              }
            },

            updateUploadProgress(message, percentage) {
                this.uploadStage.message = message;
                this.uploadStage.percentage = percentage;
            },



            async submitFormAjax() {
              const formData = new FormData(document.querySelector('#uploadForm'));
              const apiEndpoint = '/file/upload';

              const response = await fetch(apiEndpoint, {
                method: 'POST',
                body: formData
              });

              if (!response.ok) {
                 const error = await response.json();
                 throw new Error(error.message || 'ì„œë²„ì—ì„œ ì—…ë¡œë“œì˜ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
              }
              const result = await response.json();
              this.uploadId = result.uploadId;
              
              this.updateUploadProgress('ì—…ë¡œë“œ ì™„ë£Œ', 100);
              this.uploadStage.status = 'COMPLETED';

              if (this.processingMode === 'AUTO') {
                this.startSseConnection();
              } else {
                this.isProcessing = false; // Wait for manual trigger
              }
            },

            forceUpload() {
                document.querySelector('input[name="forceUpload"]').value = 'true';
                document.getElementById('duplicateModal').close();
                this.submitFormAjax().catch(error => {
                    this.errorMessages.push('ê°•ì œ ì—…ë¡œë“œ ì‹¤íŒ¨: ' + error.message);
                    this.overallStatus = 'FAILED';
                    this.isProcessing = false;
                });
            },
            
            viewExistingFile() {
                if(this.existingFileId) {
                    window.open(`/history/${this.existingFileId}`, '_blank');
                }
            },

            startSseConnection() {
                if (!this.uploadId) return;

                // Cancel any pending reconnection timer
                if (this.sseReconnectTimer) {
                    clearTimeout(this.sseReconnectTimer);
                    this.sseReconnectTimer = null;
                }

                // Close existing connection if any
                if (this.sseEventSource) {
                    this.sseEventSource.close();
                    this.sseEventSource = null;
                }

                this.isProcessing = true;

                // Save uploadId to sessionStorage for persistence
                sessionStorage.setItem('currentUploadId', this.uploadId);

                console.log(`Starting SSE connection for uploadId: ${this.uploadId} (attempt ${this.sseReconnectAttempts + 1}/${this.maxSseReconnectAttempts})`);

                this.sseEventSource = new EventSource(`/progress/stream/${this.uploadId}`);

                // Handle successful connection
                this.sseEventSource.addEventListener('connected', (event) => {
                    console.log('SSE connected:', event.data);
                    this.sseReconnectAttempts = 0; // Reset retry count on successful connection
                    this.sseReconnectDelay = 2000; // Reset delay
                });

                // Handle heartbeat
                this.sseEventSource.addEventListener('heartbeat', (event) => {
                    console.log('SSE heartbeat received');
                    this.sseReconnectAttempts = 0; // Reset retry count on heartbeat
                });

                // Handle progress events
                this.sseEventSource.addEventListener('progress', (event) => this.handleProgressEvent(event));

                // Handle connection error with auto-reconnection
                this.sseEventSource.onerror = (error) => {
                    console.error('SSE error:', error);

                    // Close the failed connection
                    if (this.sseEventSource) {
                        this.sseEventSource.close();
                        this.sseEventSource = null;
                    }

                    // Attempt reconnection if under max retries
                    if (this.sseReconnectAttempts < this.maxSseReconnectAttempts) {
                        this.sseReconnectAttempts++;
                        const delay = this.sseReconnectDelay * Math.pow(2, this.sseReconnectAttempts - 1); // Exponential backoff

                        console.log(`SSE connection lost. Reconnecting in ${delay/1000} seconds... (attempt ${this.sseReconnectAttempts}/${this.maxSseReconnectAttempts})`);

                        // Show reconnection message to user
                        this.errorMessages = this.errorMessages.filter(m => !m.includes('ì¬ì—°ê²° ì‹œë„ ì¤‘'));
                        this.errorMessages.push(`SSE ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ${delay/1000}ì´ˆ í›„ ì¬ì—°ê²° ì‹œë„ ì¤‘... (${this.sseReconnectAttempts}/${this.maxSseReconnectAttempts})`);

                        // Schedule reconnection
                        this.sseReconnectTimer = setTimeout(() => {
                            this.startSseConnection();
                        }, delay);

                    } else {
                        // Max retries reached
                        console.error('SSE max reconnection attempts reached');
                        this.errorMessages.push('SSE ì—°ê²°ì„ ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ì£¼ì„¸ìš”.');
                        this.overallStatus = 'FAILED';
                        this.isProcessing = false;
                    }
                };
            },

            handleProgressEvent(event) {
                const progress = JSON.parse(event.data);
                if (progress.uploadId !== this.uploadId) return;

                // Reset reconnection attempts on successful progress event
                this.sseReconnectAttempts = 0;

                // Explicitly activate the stage display when any progress event for it arrives
                if (progress.step === 'UPLOAD') this.uploadStage.active = true;
                if (progress.step === 'PARSE') {
                    this.parseStage.active = true;
                    this.parsingInProgress = true;
                }
                if (progress.step === 'VALIDATE') {
                    this.validateStage.active = true;
                    this.validationInProgress = true;
                }
                if (progress.step === 'LDAP_UPLOAD') {
                    this.ldapStage.active = true;
                    this.ldapInProgress = true;
                }

                let targetStage;
                switch (progress.step) {
                    case 'UPLOAD': targetStage = this.uploadStage; break;
                    case 'PARSE':
                        targetStage = this.parseStage;
                        // Mark parsing as completed when status is PARSING_COMPLETED
                        if (progress.status === 'PARSING_COMPLETED') {
                            this.parsingCompleted = true;
                            this.parsingInProgress = false;
                        }
                        break;
                    case 'VALIDATE':
                        targetStage = this.validateStage;
                        // Mark validation as completed when status is VALIDATION_COMPLETED
                        if (progress.status === 'VALIDATION_COMPLETED') {
                            this.validationCompleted = true;
                            this.validationInProgress = false;
                        }
                        break;
                    case 'LDAP_UPLOAD':
                        targetStage = this.ldapStage;
                        // Mark LDAP upload as completed when status is LDAP_SAVING_COMPLETED
                        if (progress.status === 'LDAP_SAVING_COMPLETED') {
                            this.ldapCompleted = true;
                            this.ldapInProgress = false;
                        }
                        break;
                    case 'PAUSE': // Handle PAUSE step for updating UI flags for manual buttons
                        if (progress.stage === 'PARSING_COMPLETED') {
                            this.parsingCompleted = true;
                            this.parsingInProgress = false;
                        } else if (progress.stage === 'VALIDATION_COMPLETED') {
                            this.validationCompleted = true;
                            this.validationInProgress = false;
                        } else if (progress.stage === 'LDAP_SAVING_COMPLETED') {
                            this.ldapCompleted = true;
                            this.ldapInProgress = false;
                        }
                        this.isProcessing = false; // Re-enable manual control buttons
                        return; // PAUSE is a special state, not a continuous progress update
                }

                if (targetStage) {
                    targetStage.message = progress.message;
                    targetStage.percentage = progress.percentage;
                    targetStage.status = progress.status;
                    // Parse details field and format it
                    targetStage.details = this.formatStageDetails(progress);
                }

                if (progress.errorMessage) {
                    this.errorMessages.push(`[${progress.step}] ${progress.errorMessage}`);
                }

                if (progress.step === 'FINALIZED' || progress.status === 'FAILED') {
                    this.overallStatus = progress.step === 'FINALIZED' ? 'FINALIZED' : 'FAILED';
                    this.overallMessage = progress.message;
                    this.isProcessing = false;

                    // Clear all in-progress flags
                    this.parsingInProgress = false;
                    this.validationInProgress = false;
                    this.ldapInProgress = false;

                    // Clear sessionStorage since processing is complete
                    sessionStorage.removeItem('currentUploadId');

                    // Clear reconnection state
                    this.sseReconnectAttempts = 0;
                    if (this.sseReconnectTimer) {
                        clearTimeout(this.sseReconnectTimer);
                        this.sseReconnectTimer = null;
                    }

                    // Ensure all stages are properly finalized
                    const stages = [this.uploadStage, this.parseStage, this.validateStage, this.ldapStage];
                    if(this.overallStatus === 'FINALIZED') {
                        stages.forEach(stage => {
                            if (stage.active) {
                                stage.percentage = 100;
                                stage.status = 'COMPLETED';
                            }
                        });
                    } else { // FAILED
                        stages.forEach(stage => {
                            if (stage.active && stage.status !== 'COMPLETED') {
                                stage.status = 'FAILED';
                            }
                        });
                    }

                    if (this.sseEventSource) {
                        this.sseEventSource.close();
                        this.sseEventSource = null;
                    }
                    showNotification(progress.message, this.overallStatus === 'FINALIZED' ? 'success' : 'error');
                }
            },
            
            async triggerManualStep(step) {
                if (!this.uploadId) { showNotification('ì—…ë¡œë“œëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.', 'warning'); return; }
                this.isProcessing = true;
                this.errorMessages = this.errorMessages.filter(e => !e.startsWith(`[${step}]`));

                // Step name translations
                const stepNames = {
                    'PARSE': 'íŒŒì‹±',
                    'VALIDATE': 'ê²€ì¦',
                    'LDAP_UPLOAD': 'LDAP ì €ì¥'
                };

                // Set in-progress flag for the current step
                if (step === 'PARSE') {
                    this.parsingInProgress = true;
                } else if (step === 'VALIDATE') {
                    this.validationInProgress = true;
                } else if (step === 'LDAP_UPLOAD') {
                    this.ldapInProgress = true;
                }

                // CRITICAL: Start SSE connection BEFORE triggering the API
                // This ensures we can receive progress updates during processing
                this.startSseConnection();

                // Wait for SSE connection to establish (500ms delay)
                await new Promise(resolve => setTimeout(resolve, 500));

                // Map step names to API endpoints
                const endpointMap = {
                    'PARSE': 'parse',
                    'VALIDATE': 'validate',
                    'LDAP_UPLOAD': 'upload-to-ldap'
                };
                const endpoint = endpointMap[step];

                try {
                    console.log(`[triggerManualStep] step=${step}, stepName=${stepNames[step]}, endpoint=${endpoint}`);
                    const response = await fetch(`/api/processing/${endpoint}/${this.uploadId}`, { method: 'POST' });
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.message || 'ìˆ˜ë™ ì²˜ë¦¬ ì‹œì‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                    }
                    const notificationMessage = `${stepNames[step]} ë‹¨ê³„ ì™„ë£Œë¨`;
                    console.log(`[triggerManualStep] Showing notification: ${notificationMessage}`);
                    showNotification(notificationMessage, 'success');
                } catch (error) {
                    this.errorMessages.push(`[${step}] ${error.message}`);
                    this.isProcessing = false;

                    // Clear in-progress flag on error
                    if (step === 'PARSE') {
                        this.parsingInProgress = false;
                    } else if (step === 'VALIDATE') {
                        this.validationInProgress = false;
                    } else if (step === 'LDAP_UPLOAD') {
                        this.ldapInProgress = false;
                    }
                }
            },
            
            triggerParse() { this.triggerManualStep('PARSE'); },
            triggerValidate() { this.triggerManualStep('VALIDATE'); },
            triggerLdapUpload() { this.triggerManualStep('LDAP_UPLOAD'); },

            formatStageDetails(progress) {
                if (!progress) return '';

                let html = '';

                // If completed, show detailed statistics
                if (progress.status === 'COMPLETED' && progress.details && progress.details.trim() !== '') {
                    // Parse details and create badges
                    const details = progress.details.split(',').map(d => d.trim());
                    details.forEach(detail => {
                        if (detail) {
                            // Determine badge color based on content
                            let badgeClass = 'badge-primary';
                            if (detail.includes('CSCA')) {
                                badgeClass = 'badge-success';
                            } else if (detail.includes('DSC_NC')) {
                                badgeClass = 'badge-accent';
                            } else if (detail.includes('DSC')) {
                                badgeClass = 'badge-info';
                            } else if (detail.includes('CRL')) {
                                badgeClass = 'badge-warning';
                            } else if (detail.includes('ìœ íš¨')) {
                                badgeClass = 'badge-success';
                            } else if (detail.includes('ë¬´íš¨')) {
                                badgeClass = 'badge-error';
                            } else if (detail.includes('ì‹¤íŒ¨')) {
                                badgeClass = 'badge-error';
                            }
                            html += `<div><span class="badge badge-sm ${badgeClass}">${detail}</span></div>`;
                        }
                    });
                }
                // If in progress, show current progress
                else if (progress.processedCount > 0 && progress.totalCount > 0) {
                    const percentage = Math.round((progress.processedCount / progress.totalCount) * 100);
                    html += `<div class="col-span-3"><div class="flex items-center gap-2">`;
                    html += `<span class="text-xs font-medium">ì§„í–‰ë¥ : ${percentage}%</span>`;
                    html += `<span class="text-xs text-gray-500">(${progress.processedCount} / ${progress.totalCount})</span>`;
                    html += `</div></div>`;
                }
                // Show details if available
                else if (progress.details && progress.details.trim() !== '') {
                    html += `<div class="col-span-3"><span class="text-xs opacity-70">${progress.details}</span></div>`;
                }

                return html;
            },

            destroySseConnection() {
                // Clear reconnection timer
                if (this.sseReconnectTimer) {
                    clearTimeout(this.sseReconnectTimer);
                    this.sseReconnectTimer = null;
                }

                // Close SSE connection
                if (this.sseEventSource) {
                    this.sseEventSource.close();
                    this.sseEventSource = null;
                }

                // Reset reconnection state
                this.sseReconnectAttempts = 0;
                this.sseReconnectDelay = 2000;
            }
          };
        }

        // Global utility functions
        function formatFileSize(bytes) {
          if (bytes === 0) return '0 Bytes';
          const k = 1024;
          const sizes = ['Bytes', 'KB', 'MB', 'GB'];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function showToast(message, type = 'info') {
          const toastContainer = document.getElementById('toast-container');
          const toast = document.createElement('div');
          const alertClass = {
            success: 'alert-success',
            error: 'alert-error',
            warning: 'alert-warning',
            info: 'alert-info'
          }[type];

          toast.className = `alert ${alertClass} shadow-lg`;
          toast.innerHTML = `<div>${message}</div>`;
          
          toastContainer.appendChild(toast);
          setTimeout(() => {
              toast.style.opacity = '0';
              setTimeout(() => toast.remove(), 300);
          }, 5000);
        }

      </script>
    </th:block>
  </body>
</html>