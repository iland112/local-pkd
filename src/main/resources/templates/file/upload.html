<!DOCTYPE html>
<html
  lang="ko"
  xmlns:th="http://www.thymeleaf.org"
  xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
  layout:decorate="~{layout/main}"
>
  <body>
    <div layout:fragment="content">
      <div
        class="container mx-auto px-4 py-8 max-w-5xl"
        x-data="uploadPageState()"
        @alpine:init="init()"
      >

        <!-- Success Alert -->
        <div th:if="${success}" class="alert alert-success mb-4 shadow-lg" x-data="{ show: true }" x-show="show" x-init="setTimeout(() => show = false, 5000)">
          <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
          <span th:text="${success}">Success message</span>
          <button @click="show = false" class="btn btn-sm btn-ghost">✕</button>
        </div>

        <!-- Error Alert -->
        <div th:if="${error}" class="alert alert-error mb-4 shadow-lg" x-data="{ show: true }" x-show="show">
          <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
          <span th:text="${error}">Error message</span>
          <button @click="show = false" class="btn btn-sm btn-ghost">✕</button>
        </div>

        <div class="grid grid-cols-1 gap-6">
          <!-- Upload Function Card -->
          <div id="uploadFunctionCard" class="col-span-full">
            <div class="card bg-base-100 shadow-xl">
              <div class="card-body">
                <!-- Dynamic Title Based on File Type -->
                <h2 class="card-title text-2xl">
                  <i :class="fileTypeIcon" class="text-primary"></i>
                  <span x-text="fileTypeTitle"></span>
                </h2>
                <p class="text-sm text-base-content opacity-70 mb-4" x-text="fileTypeDescription"></p>

                <!-- Processing Mode Selector Fragment -->
                <div class="mb-6 pb-6 border-b">
                  <th:block th:replace="~{fragments/processing-mode-selector :: mode-selector(selected='AUTO')}" />
                </div>

                <!-- Upload Form -->
                <form id="uploadForm" method="post" enctype="multipart/form-data">
                  <!-- File Input -->
                  <div class="form-control w-full">
                    <label class="label">
                      <span class="label-text font-semibold">
                        <i class="fas fa-file-upload text-primary mr-1"></i>
                        파일 선택
                      </span>
                    </label>
                    <input
                      id="fileInput"
                      type="file"
                      name="file"
                      :accept="fileAccept"
                      class="file-input file-input-bordered file-input-primary w-full"
                      required
                      @change="handleFileSelection"
                    />
                    <label class="label">
                      <span class="label-text-alt">최대 파일 크기: 100MB</span>
                      <span id="fileInfo" class="label-text-alt font-semibold text-primary" x-text="fileInfo"></span>
                    </label>
                  </div>

                  <!-- File Type Warning (if not recognized) -->
                  <div x-show="!isValidFileType" class="alert alert-warning mt-4">
                    <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>
                    <div>
                      <h4 class="font-bold">지원하지 않는 파일 형식</h4>
                      <div class="text-xs">
                        <p x-text="'LDIF (.ldif) 또는 Master List (.ml) 파일만 업로드 가능합니다'"></p>
                      </div>
                    </div>
                  </div>

                  <!-- Expected Checksum (Optional) -->
                  <div class="form-control w-full mt-4">
                    <label class="label">
                      <span class="label-text font-semibold">
                        <i class="fas fa-shield-alt text-secondary mr-1"></i>
                        예상 체크섬 (선택사항)
                      </span>
                    </label>
                    <input
                      type="text"
                      name="expectedChecksum"
                      placeholder="SHA-1 체크섬 (예: a1b2c3d4...)"
                      class="input input-bordered w-full"
                    />
                    <label class="label">
                      <span class="label-text-alt">ICAO PKD에서 제공하는 체크섬을 입력하면 파일 무결성을 검증합니다.</span>
                    </label>
                  </div>

                  <!-- Hidden Fields -->
                  <input type="hidden" id="fileHashInput" name="fileHash" />
                  <input type="hidden" id="forceUploadInput" name="forceUpload" value="false" />
                  <input type="hidden" id="processingModeInput" name="processingMode" x-model="processingMode" />

                  <!-- Action Buttons -->
                  <div class="card-actions justify-end mt-6">
                    <button type="button" onclick="window.location.href='/upload-history'" class="btn btn-outline gap-2">
                      <i class="fas fa-history"></i>
                      업로드 이력
                    </button>
                    <button type="button" id="uploadBtn" @click="handleUpload()" class="btn btn-primary gap-2">
                      <i class="fas fa-cloud-upload-alt"></i>
                      업로드
                    </button>
                  </div>
                </form>
              </div>
            </div>
          </div>

          <!-- Upload Process Card -->
          <div id="uploadProcessCard" class="col-span-full mt-6"
               x-show="isProcessing || uploadId || (processingMode === 'MANUAL' && uploadId)"
               x-transition:enter="transition ease-out duration-300"
               x-transition:enter-start="opacity-0 transform -translate-y-2"
               x-transition:enter-end="opacity-100 transform translate-y-0"
               th:with="uploadIdFromModel=${uploadId}"
          >
            <div class="card bg-base-100 shadow-xl">
              <div class="card-body">
                <h3 class="card-title text-lg">
                  <i class="fas fa-info-circle text-info"></i>
                  업로드 진행 상황
                </h3>
                <div class="mt-4 border-t pt-4">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-sm font-semibold" x-text="currentStepMessage"></span>
                        <span class="text-sm text-base-content/70" x-text="stepPercentage + '%'"></span>
                    </div>
                    <progress id="stepProgress" class="progress progress-primary w-full" :value="stepPercentage" max="100"></progress>

                    <div x-show="stepError" class="alert alert-error mt-4">
                        <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                        <div class="text-xs" x-text="stepError"></div>
                    </div>
                </div>

                <!-- Manual Mode Control Panel Fragment (if in MANUAL mode) -->
                <div x-show="processingMode === 'MANUAL' && uploadId && !isProcessing" class="mt-6 border-t pt-4">
                    <h4 class="font-bold text-md mb-3">수동 처리 제어</h4>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                        <button :disabled="parsingStarted" @click="triggerParse()" class="btn btn-sm" :class="parsingStarted ? 'btn-success' : 'btn-primary'">
                            <i class="fas" :class="parsingStarted ? 'fa-check-circle' : 'fa-play'"></i>
                            <span x-text="parsingStarted ? '파싱 완료' : '파싱 시작'"></span>
                        </button>
                        <button :disabled="!parsingStarted || validationStarted" @click="triggerValidate()" class="btn btn-sm" :class="validationStarted ? 'btn-success' : 'btn-primary'">
                            <i class="fas" :class="validationStarted ? 'fa-check-circle' : 'fa-play'"></i>
                            <span x-text="validationStarted ? '검증 완료' : '검증 시작'"></span>
                        </button>
                        <button :disabled="!validationStarted || ldapStarted" @click="triggerLdapUpload()" class="btn btn-sm" :class="ldapStarted ? 'btn-success' : 'btn-primary'">
                            <i class="fas" :class="ldapStarted ? 'fa-check-circle' : 'fa-play'"></i>
                            <span x-text="ldapStarted ? 'LDAP 저장 완료' : 'LDAP 저장 시작'"></span>
                        </button>
                    </div>
                </div>

                <div class="divider"></div>

                <!-- File Type Info (kept for consistency with old Info Card) -->
                <div class="alert alert-info">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                  <div class="text-xs">
                    <p class="font-semibold">지원 형식</p>
                    <p x-text="fileTypeInfoText"></p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>      </div>

      <!-- Duplicate Warning Modal -->
      <dialog id="duplicateModal" class="modal">
        <div class="modal-box max-w-2xl">
          <form method="dialog">
            <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button>
          </form>
          <h3 class="font-bold text-lg text-warning mb-4">
            <i class="fas fa-exclamation-triangle mr-2"></i>
            중복 파일 경고
          </h3>

          <div class="alert alert-warning mb-4">
            <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>
            <div>
              <h4 class="font-bold">동일한 파일이 이미 업로드되었습니다</h4>
              <div id="duplicateMessage" class="text-sm mt-1"></div>
            </div>
          </div>

          <div class="overflow-x-auto">
            <table class="table table-sm">
              <tbody>
                <tr>
                  <th>파일명</th>
                  <td id="dupFileName" class="font-mono text-xs">-</td>
                </tr>
                <tr>
                  <th>업로드 ID</th>
                  <td id="dupFileId" class="font-mono text-xs">-</td>
                </tr>
                <tr>
                  <th>업로드 일시</th>
                  <td id="dupUploadDate">-</td>
                </tr>
                <tr>
                  <th>버전</th>
                  <td id="dupVersion">-</td>
                </tr>
                <tr>
                  <th>상태</th>
                  <td id="dupStatus">-</td>
                </tr>
              </tbody>
            </table>
          </div>

          <div class="modal-action">
            <form method="dialog">
              <button class="btn btn-outline">취소</button>
            </form>
            <button onclick="viewExistingFile()" class="btn btn-info gap-2">
              <i class="fas fa-eye"></i>
              기존 파일 보기
            </button>
          </div>
        </div>
        <form method="dialog" class="modal-backdrop">
          <button>close</button>
        </form>
      </dialog>

    </div>

    <th:block layout:fragment="script-content">
      <script>
        /**
         * Alpine.js State Management for Unified Upload Page
         */
        function uploadPageState() {
          return {
            // File type detection
            fileType: 'unknown', // 'ldif' or 'ml'
            fileTypeIcon: 'fas fa-question-circle',
            fileTypeTitle: '파일 업로드',
            fileTypeDescription: '파일을 선택해주세요',
            fileTypeInfoText: 'LDIF (LDAP Data Interchange Format) 또는 Master List 파일',
            fileAccept: '.ldif,.ml',
            isValidFileType: true,
            fileInfo: '',

            // Upload state
            selectedFile: null,
            calculatedHash: null,
            existingFileId: null,
            uploadId: null, // Store current upload ID for SSE

            // Processing mode
            processingMode: 'AUTO',

            // Processing state for "Upload Process Card"
            isProcessing: false,
            currentStepMessage: '파일 대기 중...',
            stepPercentage: 0,
            stepError: '',
            parsingStarted: false,
            validationStarted: false,
            ldapStarted: false,
            sseEventSource: null, // Store SSE EventSource instance

            // Initialize state
            init() {
              console.log('Upload page initialized');
              this.$watch('selectedFile', (value) => {
                if (value) {
                    this.fileInfo = `${this.selectedFile.name} (${formatFileSize(this.selectedFile.size)})`;
                } else {
                    this.fileInfo = '';
                }
              });

              // Add event listener for when processing mode changes globally (e.g. from fragment)
              this.$el.addEventListener('processing-mode-changed', (event) => {
                  this.processingMode = event.detail.mode;
                  console.log('Processing mode updated to:', this.processingMode);
              });
            },

            // Handle file selection
            handleFileSelection(event) {
              this.selectedFile = event.target.files[0];
              if (!this.selectedFile) return;

              // Detect file type
              const fileName = this.selectedFile.name.toLowerCase();
              if (fileName.endsWith('.ldif')) {
                this.setFileLdif();
              } else if (fileName.endsWith('.ml')) {
                this.setFileMasterList();
              } else {
                this.setFileUnknown();
              }
            },

            // Set to LDIF mode
            setFileLdif() {
              this.fileType = 'ldif';
              this.fileTypeIcon = 'fas fa-file-code';
              this.fileTypeTitle = 'LDIF 파일 업로드';
              this.fileTypeDescription = 'LDIF (LDAP Data Interchange Format) 파일을 업로드합니다.';
              this.fileTypeInfoText = 'RFC 2849 표준 LDIF';
              this.isValidFileType = true;
            },

            // Set to Master List mode
            setFileMasterList() {
              this.fileType = 'ml';
              this.fileTypeIcon = 'fas fa-file-signature';
              this.fileTypeTitle = 'Master List 파일 업로드';
              this.fileTypeDescription = 'ICAO CSCA Master List (CMS 서명 파일)을 업로드합니다.';
              this.fileTypeInfoText = 'CMS (Cryptographic Message Syntax)';
              this.isValidFileType = true;
            },

            // Set to unknown file
            setFileUnknown() {
              this.fileType = 'unknown';
              this.fileTypeIcon = 'fas fa-question-circle';
              this.fileTypeTitle = '지원하지 않는 파일 형식';
              this.fileTypeDescription = 'LDIF (.ldif) 또는 Master List (.ml) 파일만 업로드 가능합니다.';
              this.isValidFileType = false;
            },

            // Main upload handler
            async handleUpload() {
              if (!this.selectedFile) {
                showToast('파일을 선택해주세요.', 'warning');
                return;
              }

              if (!this.isValidFileType) {
                showToast('지원하지 않는 파일 형식입니다.', 'error');
                return;
              }

              // Validate file size
              const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB
              if (this.selectedFile.size > MAX_FILE_SIZE) {
                showToast('파일 크기는 100MB 이하여야 합니다.', 'error');
                return;
              }

              // Reset processing state
              this.isProcessing = true;
              this.currentStepMessage = '파일 해시 계산 중...';
              this.stepPercentage = 0;
              this.stepError = '';
              this.parsingStarted = false;
              this.validationStarted = false;
              this.ldapStarted = false;
              this.uploadId = null;

              try {
                // Step 1: Calculate SHA-256 hash
                this.updateProgressBar('파일 해시 계산 중...', 30);
                this.calculatedHash = await calculateSHA256(this.selectedFile);
                document.getElementById('fileHashInput').value = this.calculatedHash;

                // Step 2: Check duplicate
                this.updateProgressBar('중복 파일 검사 중...', 60);
                const isDuplicate = await this.checkDuplicate();

                if (isDuplicate) {
                  this.isProcessing = false; // Stop progress if modal is shown
                  return; // Modal shown, user needs to decide
                }

                // Step 3: Submit form via AJAX to capture uploadId
                this.updateProgressBar('파일 업로드 중...', 90);
                await this.submitFormAjax();

              } catch (error) {
                console.error('Upload error:', error);
                this.currentStepMessage = '업로드 실패';
                this.stepError = error.message;
                this.isProcessing = false;
                showToast('업로드 중 오류가 발생했습니다: ' + error.message, 'error');
              }
            },

            // Check duplicate via API
            async checkDuplicate() {
              const apiEndpoint = this.fileType === 'ldif'
                ? '/file/ldif/api/check-duplicate'
                : '/file/masterlist/api/check-duplicate';

              const response = await fetch(apiEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  fileName: this.selectedFile.name,
                  fileSize: this.selectedFile.size,
                  fileHash: this.calculatedHash
                })
              });

              if (!response.ok) {
                throw new Error('중복 검사 실패');
              }

              const result = await response.json();

              if (result.isDuplicate) {
                // Show duplicate modal
                document.getElementById('duplicateMessage').textContent = result.message;
                document.getElementById('dupFileName').textContent = result.existingFileName || '-';
                document.getElementById('dupFileId').textContent = result.existingFileId || '-';
                document.getElementById('dupUploadDate').textContent = result.existingUploadDate
                  ? new Date(result.existingUploadDate).toLocaleString('ko-KR')
                  : '-';
                document.getElementById('dupVersion').textContent = result.existingVersion || '-';
                document.getElementById('dupStatus').textContent = result.existingStatus || '-';

                this.existingFileId = result.existingFileId;

                document.getElementById('duplicateModal').showModal();
                return true;
              }

              return false;
            },

            // Submit form via AJAX
            async submitFormAjax() {
              const formData = new FormData(document.getElementById('uploadForm'));
              formData.append('processingMode', this.processingMode); // Ensure processing mode is sent

              const response = await fetch(document.getElementById('uploadForm').action, {
                method: 'POST',
                body: formData
              });

              if (!response.ok) {
                throw new Error('파일 업로드 실패');
              }

              // Assuming API now returns JSON with uploadId, and potentially redirect
              const result = await response.json(); 
              this.uploadId = result.uploadId;

              if (this.uploadId) {
                this.updateProgressBar('파일 업로드 완료. 처리를 시작합니다.', 100);
                showToast('파일 업로드 완료. 처리를 시작합니다.', 'success');

                // Trigger processing based on mode
                this.triggerProcessing();
              } else {
                // Fallback: This case should ideally not happen if API returns uploadId
                this.currentStepMessage = '파일 업로드 완료 (업로드 ID 없음)';
                this.isProcessing = false;
                showToast('파일 업로드 완료', 'success');
              }
            },

            // Trigger processing based on mode (now uses this.uploadId)
            triggerProcessing() {
              if (this.processingMode === 'AUTO') {
                this.startSseConnection(); // Start SSE for AUTO mode
              } else {
                // MANUAL mode: Wait for user action
                this.currentStepMessage = '파일 업로드 완료. 수동 모드에서 다음 단계를 진행하세요.';
                this.isProcessing = false; // Stop auto-progress, wait for manual actions
                showToast('파일 업로드 완료. 수동 모드에서 다음 단계를 진행하세요.', 'info');
              }
            },
            
            // --- SSE Progress Management (Integrated into Alpine) ---
            startSseConnection() {
                if (!this.uploadId) {
                    console.warn('Cannot start SSE: uploadId is null.');
                    return;
                }

                if (this.sseEventSource) {
                    this.sseEventSource.close();
                    this.sseEventSource = null;
                }

                this.sseEventSource = new EventSource(`/progress/stream/${this.uploadId}`);
                console.log('SSE connection initiated for uploadId:', this.uploadId);

                this.sseEventSource.addEventListener('progress', (event) => {
                    this.handleProgressEvent(event);
                });

                this.sseEventSource.onerror = (error) => {
                    console.error('SSE error:', error);
                    this.stepError = 'SSE 연결 오류 발생.';
                    this.isProcessing = false; // Stop processing on SSE error
                    if (this.sseEventSource) { // Ensure it exists before trying to close
                       this.sseEventSource.close();
                       this.sseEventSource = null;
                    }
                };

                this.sseEventSource.onopen = () => {
                    console.log('SSE connection opened.');
                };
            },

            handleProgressEvent(event) {
                try {
                    const progress = JSON.parse(event.data);
                    // Filter events by current uploadId
                    if (progress.uploadId !== this.uploadId) {
                        console.debug(`Ignoring progress event for different uploadId: ${progress.uploadId} (current: ${this.uploadId})`);
                        return;
                    }

                    this.currentStepMessage = progress.message;
                    this.stepPercentage = progress.percentage;
                    this.stepError = progress.errorMessage || '';

                    // Update step flags and isProcessing based on the current processing step
                    if (progress.status === 'COMPLETED') {
                        if (progress.step === 'UPLOAD') {
                            this.parsingStarted = false; // Reset for next steps (already done in init, but good for clarity)
                            this.validationStarted = false;
                            this.ldapStarted = false;
                            this.isProcessing = false; // Manual mode: Ready for next step after initial upload
                        } else if (progress.step === 'PARSE') {
                            this.parsingStarted = true; // Parsing step is completed
                            this.isProcessing = false; // Manual mode: Ready for next step (validation)
                        } else if (progress.step === 'VALIDATE') {
                            this.validationStarted = true; // Validation step is completed
                            this.isProcessing = false; // Manual mode: Ready for next step (ldap)
                        } else if (progress.step === 'LDAP_UPLOAD') {
                            this.ldapStarted = true; // LDAP upload step is completed
                            this.isProcessing = false; // Manual mode: All manual steps complete
                        } else if (progress.step === 'FINALIZED') { // Overall final completion
                            this.isProcessing = false;
                            this.stepPercentage = 100;
                            this.currentStepMessage = '모든 처리 완료!';
                            showToast('파일 처리 완료', 'success');
                            if (this.sseEventSource) {
                                this.sseEventSource.close();
                                this.sseEventSource = null;
                            }
                        }
                    } else if (progress.status === 'FAILED') {
                        this.isProcessing = false;
                        this.stepError = progress.errorMessage || '알 수 없는 오류 발생';
                        this.currentStepMessage = '처리 실패';
                        showToast('파일 처리 실패: ' + this.stepError, 'error');
                        if (this.sseEventSource) {
                            this.sseEventSource.close();
                            this.sseEventSource = null;
                        }
                    } else {
                        this.isProcessing = true; // Keep processing active if not completed or failed
                    }

                } catch (e) {
                    console.error('Failed to parse SSE progress data:', e, event.data);
                    this.stepError = 'SSE 데이터 파싱 오류: ' + e.message;
                    this.isProcessing = false;
                }
            },
            
            // --- Manual Step Triggers (now use this.uploadId) ---
            async triggerParse() {
                if (!this.uploadId) { showToast('업로드된 파일이 없습니다.', 'warning'); return; }
                this.isProcessing = true;
                this.currentStepMessage = '파일 파싱 시작...';
                this.stepPercentage = 0;
                this.stepError = '';
                try {
                    const response = await fetch(`/api/pkd/parse/${this.uploadId}`, { method: 'POST' });
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(errorText || '파일 파싱 실패');
                    }
                    showToast('파일 파싱 시작됨', 'info');
                    this.startSseConnection(); // Reconnect SSE for progress
                } catch (error) {
                    this.stepError = '파싱 실패: ' + error.message;
                    this.isProcessing = false;
                    showToast('파싱 실패: ' + error.message, 'error');
                }
            },

            async triggerValidate() {
                if (!this.uploadId) { showToast('업로드된 파일이 없습니다.', 'warning'); return; }
                this.isProcessing = true;
                this.currentStepMessage = '인증서 검증 시작...';
                this.stepPercentage = 0;
                this.stepError = '';
                try {
                    const response = await fetch(`/api/pkd/validate/${this.uploadId}`, { method: 'POST' });
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(errorText || '인증서 검증 실패');
                    }
                    showToast('인증서 검증 시작됨', 'info');
                    this.startSseConnection(); // Reconnect SSE for progress
                } catch (error) {
                    this.stepError = '검증 실패: ' + error.message;
                    this.isProcessing = false;
                    showToast('검증 실패: ' + error.message, 'error');
                }
            },

            async triggerLdapUpload() {
                if (!this.uploadId) { showToast('업로드된 파일이 없습니다.', 'warning'); return; }
                this.isProcessing = true;
                this.currentStepMessage = 'LDAP 업로드 시작...';
                this.stepPercentage = 0;
                this.stepError = '';
                try {
                    const response = await fetch(`/api/pkd/ldap-upload/${this.uploadId}`, { method: 'POST' });
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(errorText || 'LDAP 업로드 실패');
                    }
                    showToast('LDAP 업로드 시작됨', 'info');
                    this.startSseConnection(); // Reconnect SSE for progress
                } catch (error) {
                    this.stepError = 'LDAP 업로드 실패: ' + error.message;
                    this.isProcessing = false;
                    showToast('LDAP 업로드 실패: ' + error.message, 'error');
                }
            },
            
            // Helper to update progress bar (internal to Alpine component)
            updateProgressBar(message, percentage) {
                this.currentStepMessage = message;
                this.stepPercentage = percentage;
            },

            // Function to view existing file in duplicate modal
            viewExistingFileFromModal() {
                if (this.existingFileId) {
                    window.location.href = `/upload-history?id=${this.existingFileId}`;
                }
            },

            // Close SSE connection when component is destroyed (or page navigated away)
            destroySseConnection() {
                if (this.sseEventSource) {
                    this.sseEventSource.close();
                    this.sseEventSource = null;
                    console.log('SSE connection closed.');
                }
            }
          };
        }

        // Global utility functions (kept outside Alpine component as they are general)
        function formatFileSize(bytes) {
          if (bytes === 0) return '0 Bytes';
          const k = 1024;
          const sizes = ['Bytes', 'KB', 'MB', 'GB'];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        function showToast(message, type = 'info') {
          const toast = document.createElement('div');
          const alertClass = type === 'success' ? 'alert-success' :
                            type === 'error' ? 'alert-error' :
                            type === 'warning' ? 'alert-warning' : 'alert-info';

          toast.className = `alert ${alertClass} fixed top-4 right-4 w-auto max-w-sm shadow-lg z-50`;
          toast.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span>${message}</span>
          `;

          document.body.appendChild(toast);
          setTimeout(() => toast.remove(), 3000);
        }

        async function calculateSHA256(file) {
          const buffer = await file.arrayBuffer();
          const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
          const hashArray = Array.from(new Uint8Array(hashBuffer));
          return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // --- Event Listener for beforeunload (kept global for reliability) ---
        window.addEventListener('beforeunload', function() {
          const appStateElement = document.querySelector('[x-data*="uploadPageState"]');
          if (appStateElement && appStateElement.__x) {
            const alpineComponent = appStateElement.__x.getUnobservedData();
            if (alpineComponent && alpineComponent.destroySseConnection) {
              alpineComponent.destroySseConnection();
            }
          }
        });
      </script>
    </th:block>
  </body>
</html>